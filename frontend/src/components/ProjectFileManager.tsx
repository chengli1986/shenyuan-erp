// frontend/src/components/ProjectFileManager.tsx
/**
 * È°πÁõÆÊñá‰ª∂ÁÆ°ÁêÜÁªÑ‰ª∂
 * ÂåÖÂê´Êñá‰ª∂‰∏ä‰º†„ÄÅÂàóË°®ÊòæÁ§∫„ÄÅ‰∏ãËΩΩ„ÄÅÂà†Èô§Á≠âÂäüËÉΩ
 */

import React, { useState, useEffect, useCallback } from 'react';
import {
  Card,
  Upload,
  Button,
  Table,
  Space,
  Select,
  message,
  Modal,
  Form,
  Input,
  Tag,
  Tooltip,
  Popconfirm,
  Progress,
  Row,
  Col,
  Statistic,
  Empty,
  List,
  Divider
} from 'antd';
import {
  UploadOutlined,
  DownloadOutlined,
  DeleteOutlined,
  EyeOutlined,
  InboxOutlined,
  CloudUploadOutlined,
  FolderOpenOutlined
} from '@ant-design/icons';
import type { ColumnsType } from 'antd/es/table';
import type { UploadFile, UploadProps } from 'antd/es/upload';

import { 
  ProjectFile, 
  FileType, 
  FILE_TYPE_DISPLAY,
  formatFileSize,
  getFileIcon,
  FileSystemConfig,
  BatchUploadItem,
  validateFile,
  canPreviewFile
} from '../types/projectFile';
import { ProjectFileService } from '../services/projectFile';

const { Option } = Select;
const { TextArea } = Input;
const { Dragger } = Upload;

interface ProjectFileManagerProps {
  projectId: number;
  projectName: string;
  visible: boolean;
  onCancel: () => void;
}

const ProjectFileManager: React.FC<ProjectFileManagerProps> = ({
  projectId,
  projectName,
  visible,
  onCancel
}) => {
  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [files, setFiles] = useState<ProjectFile[]>([]);
  const [loading, setLoading] = useState(false);
  const [uploadLoading, setUploadLoading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [filterType, setFilterType] = useState<FileType | ''>('');
  const [fileConfig, setFileConfig] = useState<FileSystemConfig | null>(null);
  
  // ‰∏ä‰º†Ë°®Âçï
  const [uploadForm] = Form.useForm();
  const [uploadModalVisible, setUploadModalVisible] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  // ÊâπÈáè‰∏ä‰º†
  const [batchUploadVisible, setBatchUploadVisible] = useState(false);
  const [batchFiles, setBatchFiles] = useState<BatchUploadItem[]>([]);
  const [batchUploading, setBatchUploading] = useState(false);

  // Êñá‰ª∂È¢ÑËßà
  const [previewVisible, setPreviewVisible] = useState(false);
  const [previewFile, setPreviewFile] = useState<ProjectFile | null>(null);

  // Ë°®Ê†ºÈÄâÊã©
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);

  // ÈªòËÆ§Êñá‰ª∂Á±ªÂûãÈÖçÁΩÆÔºàÈò≤Ê≠¢ÂêéÁ´ØÊé•Âè£Â§±Ë¥•Ôºâ
  const defaultFileTypes = [
    {
      value: 'award_notice',
      label: '‰∏≠Ê†áÈÄöÁü•‰π¶',
      icon: 'üìã',
      color: 'blue',
      max_count: 5,
      description: 'È°πÁõÆ‰∏≠Ê†áÈÄöÁü•‰π¶Á≠âÁõ∏ÂÖ≥Êñá‰ª∂'
    },
    {
      value: 'contract',
      label: 'ÂêàÂêåÊñá‰ª∂',
      icon: 'üìÑ',
      color: 'green',
      max_count: 10,
      description: 'È°πÁõÆÂêàÂêå„ÄÅÂçèËÆÆÁ≠âÊñá‰ª∂'
    },
    {
      value: 'attachment',
      label: 'ÈôÑ‰ª∂',
      icon: 'üìé',
      color: 'orange',
      max_count: 50,
      description: 'È°πÁõÆÁõ∏ÂÖ≥ÈôÑ‰ª∂'
    },
    {
      value: 'other',
      label: 'ÂÖ∂‰ªñÊñá‰ª∂',
      icon: 'üìÅ',
      color: 'gray',
      max_count: 20,
      description: 'ÂÖ∂‰ªñÁ±ªÂûãÊñá‰ª∂'
    }
  ];

  // Ëé∑ÂèñÊñá‰ª∂ÂàóË°®
  const fetchFiles = useCallback(async () => {
    setLoading(true);
    try {
      const response = await ProjectFileService.getProjectFiles(
        projectId,
        filterType || undefined
      );
      setFiles(response.items);
    } catch (error) {
      message.error('Ëé∑ÂèñÊñá‰ª∂ÂàóË°®Â§±Ë¥•');
      console.error('Error fetching files:', error);
    } finally {
      setLoading(false);
    }
  }, [projectId, filterType]);

  // Ëé∑ÂèñÊñá‰ª∂Á≥ªÁªüÈÖçÁΩÆ
  const fetchFileConfig = useCallback(async () => {
    try {
      const config = await ProjectFileService.getFileSystemConfig();
      setFileConfig(config);
      console.log('Ëé∑ÂèñÂà∞Êñá‰ª∂ÈÖçÁΩÆ:', config);
    } catch (error) {
      console.warn('Ëé∑ÂèñÊñá‰ª∂ÈÖçÁΩÆÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ:', error);
      // ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
      setFileConfig({
        file_types: defaultFileTypes,
        allowed_extensions: ['.pdf', '.doc', '.docx', '.xls', '.xlsx', '.jpg', '.jpeg', '.png', '.zip', '.rar'],
        max_file_size: 50 * 1024 * 1024,
        max_file_size_mb: 50
      });
    }
  }, []);

  // ÁªÑ‰ª∂ÊåÇËΩΩÊó∂Ëé∑ÂèñÊï∞ÊçÆ
  useEffect(() => {
    if (visible) {
      fetchFiles();
      fetchFileConfig();
    }
  }, [visible, fetchFiles, fetchFileConfig]);

  // Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†
  const handleUpload = async (values: any) => {
    if (!selectedFile) {
      message.error('ËØ∑ÈÄâÊã©Ë¶Å‰∏ä‰º†ÁöÑÊñá‰ª∂');
      return;
    }

    // È™åËØÅÊñá‰ª∂
    const validation = validateFile(selectedFile, values.file_type);
    if (!validation.valid) {
      message.error(validation.message);
      return;
    }

    setUploadLoading(true);
    setUploadProgress(0);

    try {
      await ProjectFileService.uploadFileWithRetry(
        projectId,
        selectedFile,
        values.file_type,
        values.description,
        'ÂΩìÂâçÁî®Êà∑', // ÂêéÁª≠‰ªéÁî®Êà∑Áä∂ÊÄÅËé∑Âèñ
        (percent) => setUploadProgress(percent)
      );

      message.success('Êñá‰ª∂‰∏ä‰º†ÊàêÂäü');
      setUploadModalVisible(false);
      uploadForm.resetFields();
      setSelectedFile(null);
      setUploadProgress(0);
      fetchFiles(); // Âà∑Êñ∞ÂàóË°®
    } catch (error: any) {
      message.error(error.response?.data?.detail || 'Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•');
    } finally {
      setUploadLoading(false);
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂‰∏ãËΩΩ
  const handleDownload = async (file: ProjectFile) => {
    try {
      await ProjectFileService.downloadFile(
        projectId,
        file.id,
        file.file_name
      );
      message.success('Êñá‰ª∂‰∏ãËΩΩÂºÄÂßã');
    } catch (error) {
      message.error('Êñá‰ª∂‰∏ãËΩΩÂ§±Ë¥•');
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂Âà†Èô§
  const handleDelete = async (file: ProjectFile) => {
    try {
      await ProjectFileService.deleteFile(projectId, file.id);
      message.success(`Êñá‰ª∂ "${file.file_name}" Âà†Èô§ÊàêÂäü`);
      fetchFiles(); // Âà∑Êñ∞ÂàóË°®
    } catch (error) {
      message.error('Êñá‰ª∂Âà†Èô§Â§±Ë¥•');
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂È¢ÑËßà
  const handlePreview = (file: ProjectFile) => {
    if (canPreviewFile(file.file_extension)) {
      setPreviewFile(file);
      setPreviewVisible(true);
    } else {
      message.info('ËØ•Êñá‰ª∂Á±ªÂûã‰∏çÊîØÊåÅÈ¢ÑËßàÔºåËØ∑‰∏ãËΩΩÊü•Áúã');
    }
  };

  // ÊâπÈáèÂà†Èô§
  const handleBatchDelete = async () => {
    const selectedFiles = files.filter(file => selectedRowKeys.includes(file.id));
    try {
      const result = await ProjectFileService.deleteMultipleFiles(
        projectId, 
        selectedFiles.map(f => f.id)
      );
      
      if (result.success > 0) {
        message.success(`ÊàêÂäüÂà†Èô§ ${result.success} ‰∏™Êñá‰ª∂`);
      }
      if (result.failed > 0) {
        message.error(`${result.failed} ‰∏™Êñá‰ª∂Âà†Èô§Â§±Ë¥•`);
      }
      
      setSelectedRowKeys([]);
      fetchFiles();
    } catch (error) {
      message.error('ÊâπÈáèÂà†Èô§Â§±Ë¥•');
    }
  };

  // ÊâπÈáè‰∏ãËΩΩ
  const handleBatchDownload = async () => {
    const selectedFiles = files.filter(file => selectedRowKeys.includes(file.id));
    try {
      await ProjectFileService.downloadMultipleFiles(projectId, selectedFiles);
      message.success('ÊâπÈáè‰∏ãËΩΩÂºÄÂßã');
    } catch (error) {
      message.error('ÊâπÈáè‰∏ãËΩΩÂ§±Ë¥•');
    }
  };

  // Â§ÑÁêÜÊâπÈáè‰∏ä‰º†
  const handleBatchUpload = async () => {
    if (batchFiles.length === 0) {
      message.error('ËØ∑Ê∑ªÂä†Ë¶Å‰∏ä‰º†ÁöÑÊñá‰ª∂');
      return;
    }

    setBatchUploading(true);
    
    const updatedFiles = [...batchFiles];
    
    try {
      await ProjectFileService.uploadMultipleFiles(
        projectId,
        batchFiles.map(item => ({
          file: item.file,
          fileType: item.fileType,
          description: item.description
        })),
        'ÂΩìÂâçÁî®Êà∑',
        (fileIndex, percent) => {
          updatedFiles[fileIndex] = {
            ...updatedFiles[fileIndex],
            progress: percent,
            status: 'uploading'
          };
          setBatchFiles([...updatedFiles]);
        },
        (fileIndex, result) => {
          updatedFiles[fileIndex] = {
            ...updatedFiles[fileIndex],
            status: result.success ? 'success' : 'error',
            error: result.success ? undefined : result.message,
            progress: 100
          };
          setBatchFiles([...updatedFiles]);
        }
      );

      const successCount = updatedFiles.filter(f => f.status === 'success').length;
      const errorCount = updatedFiles.filter(f => f.status === 'error').length;
      
      if (successCount > 0) {
        message.success(`ÊàêÂäü‰∏ä‰º† ${successCount} ‰∏™Êñá‰ª∂`);
      }
      if (errorCount > 0) {
        message.error(`${errorCount} ‰∏™Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•`);
      }

      // Âª∂ËøüÂÖ≥Èó≠ÂºπÁ™óÔºåËÆ©Áî®Êà∑ÁúãÂà∞ÁªìÊûú
      setTimeout(() => {
        setBatchUploadVisible(false);
        setBatchFiles([]);
        fetchFiles();
      }, 2000);

    } catch (error) {
      message.error('ÊâπÈáè‰∏ä‰º†Â§±Ë¥•');
    } finally {
      setBatchUploading(false);
    }
  };

  // Ëá™ÂÆö‰πâÊñá‰ª∂‰∏ä‰º†
  const uploadProps: UploadProps = {
    beforeUpload: (file) => {
      setSelectedFile(file);
      return false; // ÈòªÊ≠¢Ëá™Âä®‰∏ä‰º†
    },
    onRemove: () => {
      setSelectedFile(null);
    },
    fileList: selectedFile ? [{
      uid: '1',
      name: selectedFile.name,
      status: 'done'
    } as UploadFile] : [],
  };

  // ÊâπÈáè‰∏ä‰º†ÁöÑÊãñÊãΩÁªÑ‰ª∂
  const batchUploadProps: UploadProps = {
    multiple: true,
    beforeUpload: () => false, // ÈòªÊ≠¢Ëá™Âä®‰∏ä‰º†
    onChange: ({ fileList }) => {
      const files = fileList.map(item => item.originFileObj).filter(Boolean) as File[];
      const newBatchFiles: BatchUploadItem[] = files.map(file => ({
        file,
        fileType: FileType.OTHER,
        status: 'pending',
        progress: 0
      }));
      setBatchFiles(newBatchFiles);
    },
    showUploadList: false
  };

  // Ë°®Ê†ºË°åÈÄâÊã©ÈÖçÁΩÆ
  const rowSelection = {
    selectedRowKeys,
    onChange: setSelectedRowKeys,
  };

  // Ë°®Ê†ºÂàóÂÆö‰πâ
  const columns: ColumnsType<ProjectFile> = [
    {
      title: 'Êñá‰ª∂Âêç',
      dataIndex: 'file_name',
      key: 'file_name',
      render: (text, record) => (
        <Space>
          <span style={{ fontSize: '16px' }}>
            {getFileIcon(record.file_extension)}
          </span>
          <span>{text}</span>
        </Space>
      ),
    },
    {
      title: 'Êñá‰ª∂Á±ªÂûã',
      dataIndex: 'file_type',
      key: 'file_type',
      width: 120,
      render: (type: FileType) => {
        const config = FILE_TYPE_DISPLAY[type];
        return (
          <Tag color={config.color}>
            {config.icon} {config.name}
          </Tag>
        );
      },
    },
    {
      title: 'Êñá‰ª∂Â§ßÂ∞è',
      dataIndex: 'file_size',
      key: 'file_size',
      width: 100,
      render: (size: number) => formatFileSize(size),
    },
    {
      title: '‰∏ä‰º†‰∫∫',
      dataIndex: 'uploaded_by',
      key: 'uploaded_by',
      width: 100,
    },
    {
      title: '‰∏ä‰º†Êó∂Èó¥',
      dataIndex: 'upload_time',
      key: 'upload_time',
      width: 150,
      render: (time: string) => new Date(time).toLocaleString('zh-CN'),
    },
    {
      title: 'ÊèèËø∞',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
      render: (text) => text || '-',
    },
    {
      title: 'Êìç‰Ωú',
      key: 'action',
      width: 180,
      render: (_, record) => (
        <Space size="small">
          {canPreviewFile(record.file_extension) && (
            <Tooltip title="È¢ÑËßàÊñá‰ª∂">
              <Button
                type="link"
                icon={<EyeOutlined />}
                size="small"
                onClick={() => handlePreview(record)}
              />
            </Tooltip>
          )}
          <Tooltip title="‰∏ãËΩΩÊñá‰ª∂">
            <Button
              type="link"
              icon={<DownloadOutlined />}
              size="small"
              onClick={() => handleDownload(record)}
            />
          </Tooltip>
          <Tooltip title="Âà†Èô§Êñá‰ª∂">
            <Popconfirm
              title="Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Êñá‰ª∂ÂêóÔºü"
              onConfirm={() => handleDelete(record)}
              okText="Á°ÆÂÆö"
              cancelText="ÂèñÊ∂à"
            >
              <Button
                type="link"
                danger
                icon={<DeleteOutlined />}
                size="small"
              />
            </Popconfirm>
          </Tooltip>
        </Space>
      ),
    },
  ];

  // ÁªüËÆ°‰ø°ÊÅØ
  const stats = {
    total: files.length,
    awardNotice: files.filter(f => f.file_type === FileType.AWARD_NOTICE).length,
    contract: files.filter(f => f.file_type === FileType.CONTRACT).length,
    attachment: files.filter(f => f.file_type === FileType.ATTACHMENT).length,
    other: files.filter(f => f.file_type === FileType.OTHER).length,
  };

  // ÊâπÈáèÊìç‰ΩúÁªÑ‰ª∂
  const BatchOperations = () => {
    if (selectedRowKeys.length === 0) return null;
    
    return (
      <Space>
        <span>Â∑≤ÈÄâÊã© {selectedRowKeys.length} È°π</span>
        <Button size="small" onClick={handleBatchDownload}>
          ÊâπÈáè‰∏ãËΩΩ
        </Button>
        <Popconfirm
          title={`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedRowKeys.length} ‰∏™Êñá‰ª∂ÂêóÔºü`}
          onConfirm={handleBatchDelete}
          okText="Á°ÆÂÆö"
          cancelText="ÂèñÊ∂à"
        >
          <Button danger size="small">
            ÊâπÈáèÂà†Èô§
          </Button>
        </Popconfirm>
        <Button size="small" onClick={() => setSelectedRowKeys([])}>
          ÂèñÊ∂àÈÄâÊã©
        </Button>
      </Space>
    );
  };

  // Ê∏≤ÊüìÊñá‰ª∂Á±ªÂûãÈÄâÊã©Âô®
  const renderFileTypeSelect = () => {
    // ‰ºòÂÖà‰ΩøÁî® fileConfigÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
    const fileTypes = fileConfig?.file_types || defaultFileTypes;
    
    return (
      <Select placeholder="ËØ∑ÈÄâÊã©Êñá‰ª∂Á±ªÂûã">
        {fileTypes.map((type) => (
          <Option key={type.value} value={type.value}>
            <Space>
              <span>{type.icon}</span>
              <span>{type.label}</span>
            </Space>
          </Option>
        ))}
      </Select>
    );
  };

  return (
    <Modal
      title={`üìÅ ${projectName} - Êñá‰ª∂ÁÆ°ÁêÜ`}
      open={visible}
      onCancel={onCancel}
      width={1400}
      footer={null}
      destroyOnClose
    >
      {/* ÁªüËÆ°Âç°Áâá */}
      <Row gutter={16} style={{ marginBottom: '24px' }}>
        <Col span={6}>
          <Card size="small">
            <Statistic title="ÊÄªÊñá‰ª∂Êï∞" value={stats.total} prefix="üìä" />
          </Card>
        </Col>
        <Col span={6}>
          <Card size="small">
            <Statistic title="‰∏≠Ê†áÈÄöÁü•‰π¶" value={stats.awardNotice} prefix="üìã" />
          </Card>
        </Col>
        <Col span={6}>
          <Card size="small">
            <Statistic title="ÂêàÂêåÊñá‰ª∂" value={stats.contract} prefix="üìÑ" />
          </Card>
        </Col>
        <Col span={6}>
          <Card size="small">
            <Statistic title="ÂÖ∂‰ªñÊñá‰ª∂" value={stats.attachment + stats.other} prefix="üìé" />
          </Card>
        </Col>
      </Row>

      {/* Êìç‰ΩúÊ†è */}
      <Card size="small" style={{ marginBottom: '16px' }}>
        <Row justify="space-between" align="middle">
          <Col>
            <Space>
              <Select
                placeholder="Á≠õÈÄâÊñá‰ª∂Á±ªÂûã"
                value={filterType}
                onChange={setFilterType}
                allowClear
                style={{ width: 150 }}
              >
                {Object.entries(FILE_TYPE_DISPLAY).map(([key, config]) => (
                  <Option key={key} value={key}>
                    {config.icon} {config.name}
                  </Option>
                ))}
              </Select>
              <Button onClick={fetchFiles} loading={loading}>
                Âà∑Êñ∞
              </Button>
              <BatchOperations />
            </Space>
          </Col>
          <Col>
            <Space>
              <Button
                icon={<CloudUploadOutlined />}
                onClick={() => setBatchUploadVisible(true)}
              >
                ÊâπÈáè‰∏ä‰º†
              </Button>
              <Button
                type="primary"
                icon={<UploadOutlined />}
                onClick={() => setUploadModalVisible(true)}
              >
                ‰∏ä‰º†Êñá‰ª∂
              </Button>
            </Space>
          </Col>
        </Row>
      </Card>

      {/* Êñá‰ª∂ÂàóË°® */}
      <Card>
        <Table
          columns={columns}
          dataSource={files}
          rowKey="id"
          loading={loading}
          rowSelection={rowSelection}
          locale={{
            emptyText: <Empty description="ÊöÇÊó†Êñá‰ª∂" image={Empty.PRESENTED_IMAGE_SIMPLE} />
          }}
          scroll={{ x: 1000 }}
          pagination={{
            pageSize: 10,
            showSizeChanger: false,
            showTotal: (total) => `ÂÖ± ${total} ‰∏™Êñá‰ª∂`,
          }}
        />
      </Card>

      {/* ‰∏ä‰º†Êñá‰ª∂ÂºπÁ™ó */}
      <Modal
        title="üì§ ‰∏ä‰º†Êñá‰ª∂"
        open={uploadModalVisible}
        onCancel={() => {
          setUploadModalVisible(false);
          uploadForm.resetFields();
          setSelectedFile(null);
          setUploadProgress(0);
        }}
        footer={null}
        width={600}
      >
        <Form
          form={uploadForm}
          layout="vertical"
          onFinish={handleUpload}
        >
          <Form.Item
            label="ÈÄâÊã©Êñá‰ª∂"
            required
          >
            <Dragger {...uploadProps}>
              <p className="ant-upload-drag-icon">
                <InboxOutlined />
              </p>
              <p className="ant-upload-text">ÁÇπÂáªÊàñÊãñÊãΩÊñá‰ª∂Âà∞Ê≠§Âå∫Âüü‰∏ä‰º†</p>
              <p className="ant-upload-hint">
                ÊîØÊåÅ PDF, Word, Excel, ÂõæÁâáÁ≠âÊ†ºÂºèÔºåÂçï‰∏™Êñá‰ª∂‰∏çË∂ÖËøá 50MB
              </p>
            </Dragger>
          </Form.Item>

          <Form.Item
            name="file_type"
            label="Êñá‰ª∂Á±ªÂûã"
            rules={[{ required: true, message: 'ËØ∑ÈÄâÊã©Êñá‰ª∂Á±ªÂûã' }]}
          >
            {renderFileTypeSelect()}
          </Form.Item>

          <Form.Item
            name="description"
            label="Êñá‰ª∂ÊèèËø∞"
          >
            <TextArea
              rows={3}
              placeholder="ËØ∑ËæìÂÖ•Êñá‰ª∂ÊèèËø∞ÔºàÂèØÈÄâÔºâ"
              maxLength={200}
              showCount
            />
          </Form.Item>

          {uploadLoading && (
            <Form.Item>
              <Progress percent={uploadProgress} status="active" />
            </Form.Item>
          )}

          <Form.Item style={{ marginBottom: 0, textAlign: 'right' }}>
            <Space>
              <Button 
                onClick={() => setUploadModalVisible(false)}
                disabled={uploadLoading}
              >
                ÂèñÊ∂à
              </Button>
              <Button 
                type="primary" 
                htmlType="submit"
                loading={uploadLoading}
                disabled={!selectedFile}
              >
                {uploadLoading ? '‰∏ä‰º†‰∏≠...' : 'ÂºÄÂßã‰∏ä‰º†'}
              </Button>
            </Space>
          </Form.Item>
        </Form>
      </Modal>

      {/* ÊâπÈáè‰∏ä‰º†ÂºπÁ™ó */}
      <Modal
        title="üóÇÔ∏è ÊâπÈáè‰∏ä‰º†Êñá‰ª∂"
        open={batchUploadVisible}
        onCancel={() => {
          setBatchUploadVisible(false);
          setBatchFiles([]);
        }}
        width={800}
        footer={
          <Space>
            <Button onClick={() => setBatchUploadVisible(false)}>
              ÂèñÊ∂à
            </Button>
            <Button 
              type="primary" 
              onClick={handleBatchUpload}
              loading={batchUploading}
              disabled={batchFiles.length === 0}
            >
              ÂºÄÂßãÊâπÈáè‰∏ä‰º†
            </Button>
          </Space>
        }
      >
        <Dragger {...batchUploadProps} style={{ marginBottom: 16 }}>
          <p className="ant-upload-drag-icon">
            <FolderOpenOutlined />
          </p>
          <p className="ant-upload-text">ÈÄâÊã©Â§ö‰∏™Êñá‰ª∂ËøõË°åÊâπÈáè‰∏ä‰º†</p>
          <p className="ant-upload-hint">
            ÊîØÊåÅÂêåÊó∂ÈÄâÊã©Â§ö‰∏™Êñá‰ª∂ÔºåÊãñÊãΩÊàñÁÇπÂáªÈÄâÊã©
          </p>
        </Dragger>

        {batchFiles.length > 0 && (
          <>
            <Divider>ÂæÖ‰∏ä‰º†Êñá‰ª∂ÂàóË°® ({batchFiles.length} ‰∏™Êñá‰ª∂)</Divider>
            <List
              size="small"
              dataSource={batchFiles}
              renderItem={(item, index) => (
                <List.Item
                  actions={[
                    <Select
                      size="small"
                      value={item.fileType}
                      onChange={(value) => {
                        const newFiles = [...batchFiles];
                        newFiles[index].fileType = value;
                        setBatchFiles(newFiles);
                      }}
                      style={{ width: 120 }}
                    >
                      {Object.entries(FILE_TYPE_DISPLAY).map(([key, config]) => (
                        <Option key={key} value={key}>
                          {config.icon} {config.name}
                        </Option>
                      ))}
                    </Select>,
                    <Button
                      size="small"
                      danger
                      onClick={() => {
                        setBatchFiles(prev => prev.filter((_, i) => i !== index));
                      }}
                      disabled={batchUploading}
                    >
                      ÁßªÈô§
                    </Button>
                  ]}
                >
                  <List.Item.Meta
                    avatar={<span>{getFileIcon('.' + item.file.name.split('.').pop())}</span>}
                    title={item.file.name}
                    description={
                      <Space direction="vertical" style={{ width: '100%' }}>
                        <span>{formatFileSize(item.file.size)}</span>
                        {item.status !== 'pending' && (
                          <Progress 
                            percent={item.progress} 
                            status={item.status === 'error' ? 'exception' : 'active'}
                            size="small"
                          />
                        )}
                        {item.error && (
                          <span style={{ color: 'red', fontSize: '12px' }}>{item.error}</span>
                        )}
                      </Space>
                    }
                  />
                </List.Item>
              )}
            />
          </>
        )}
      </Modal>

      {/* Êñá‰ª∂È¢ÑËßàÂºπÁ™ó */}
      <Modal
        title={`üìÑ Êñá‰ª∂È¢ÑËßà - ${previewFile?.file_name}`}
        open={previewVisible}
        onCancel={() => setPreviewVisible(false)}
        footer={[
          <Button key="download" onClick={() => previewFile && handleDownload(previewFile)}>
            ‰∏ãËΩΩÊñá‰ª∂
          </Button>,
          <Button key="close" onClick={() => setPreviewVisible(false)}>
            ÂÖ≥Èó≠
          </Button>
        ]}
        width={900}
      >
        {previewFile && (
          <div style={{ textAlign: 'center', minHeight: '400px' }}>
            {previewFile.file_extension.toLowerCase() === '.pdf' ? (
              <iframe
                src={ProjectFileService.getFilePreviewUrl(projectId, previewFile.id)}
                width="100%"
                height="500px"
                title="Êñá‰ª∂È¢ÑËßà"
                style={{ border: 'none' }}
              />
            ) : (
              <img
                src={ProjectFileService.getFilePreviewUrl(projectId, previewFile.id)}
                alt="Êñá‰ª∂È¢ÑËßà"
                style={{ maxWidth: '100%', maxHeight: '500px', objectFit: 'contain' }}
              />
            )}
          </div>
        )}
      </Modal>
    </Modal>
  );
};

export default ProjectFileManager;